//==============================================================================
//  WARNING!!  This file is overwritten by the Block UI Styler while generating
//  the automation code. Any modifications to this file will be lost after
//  generating the code again.
//
//       Filename:  E:\Project\Response\VSAR\NXProject\AppRoot\application\Vsar_NewProject.cpp
//
//        This file was generated by the NX Block UI Styler
//        Created by: wujif
//              Version: NX 7.5
//              Date: 02-19-2011  (Format: mm-dd-yyyy)
//              Time: 17:32 (Format: hh-mm)
//
//==============================================================================

//==============================================================================
//  Purpose:  This TEMPLATE file contains C++ source to guide you in the
//  construction of your Block application dialog. The generation of your
//  dialog file (.dlx extension) is the first step towards dialog construction
//  within NX.  You must now create a NX Open application that
//  utilizes this file (.dlx).
//
//  The information in this file provides you with the following:
//
//  1.  Help on how to load and display your Block UI Styler dialog in NX
//      using APIs provided in NXOpen.BlockStyler namespace
//  2.  The empty callback methods (stubs) associated with your dialog items
//      have also been placed in this file. These empty methods have been
//      created simply to start you along with your coding requirements.
//      The method name, argument list and possible return values have already
//      been provided for you.
//==============================================================================

//------------------------------------------------------------------------------
//These includes are needed for the following template code
//------------------------------------------------------------------------------
#include <Vsar_Init_Utils.hxx>

#if defined(_WIN32) || defined(_WIN64)
#include <Windows.h>
#endif

#include <boost/filesystem.hpp>

#include <NXOpen/NXException.hxx>
#include <NXOpen/CAE_FTK_DataManager.hxx>


namespace Vsar
{
    std::string GetInstallPath()
    {
        std::string   installPath;

#if defined(_WIN32) || defined(_WIN64)

        MEMORY_BASIC_INFORMATION mbi;

        VirtualQuery(GetInstallPath, &mbi, sizeof(mbi));

        HMODULE hModule = static_cast<HMODULE>(mbi.AllocationBase);

        //hModule = GetModuleHandle("libvsarinit.dll");

        char fullPathName[_MAX_PATH];

        GetModuleFileName(hModule, fullPathName, _MAX_PATH);

        boost::filesystem::path   dllPath(fullPathName);

        installPath = dllPath.parent_path().parent_path().string();
#else
        //  TODO: add more check
        installPath = getenv("UGII_USER_DIR");
        if (*installPath.rbegin() != PATH_DELIM)
            installPath.push_back(PATH_DELIM);
#endif
        return installPath;
    }

    void CopyFile(const std::string &fromPath, const std::string &fromFileName,
                  const std::string &toPath,   const std::string &toFileName)
    {
        boost::filesystem::path fromFilePathName(fromPath);
        boost::filesystem::path toFilePathName(toPath);

        fromFilePathName /= fromFileName;
        toFilePathName   /= toFileName;

        if (boost::filesystem::exists(toFilePathName))
            boost::filesystem::remove_all(toFilePathName);

        boost::filesystem::copy_file(fromFilePathName, toFilePathName);
    }

    void CopyDirectory(const std::string &fromPathName, const std::string &toPathName)
    {
        namespace bfs = boost::filesystem;

        //  Copy part files to location
        const bfs::path   fromPath(fromPathName);

        bfs::directory_iterator  iter(fromPath);

        const bfs::path   toPath(toPathName);

        bfs::path         fromFilePathName;
        bfs::path         toFilePathName;

        //  copy all the files in template folder "common" to project path
        while (iter != bfs::directory_iterator())
        {
            fromFilePathName = iter->path();

            toFilePathName = toPath / fromFilePathName.filename();
            if (bfs::exists(toFilePathName))
                bfs::remove_all(toFilePathName);

            bfs::copy_file(fromFilePathName, toFilePathName);
            ++iter;
        }
    }

    int LoadResult(const std::string &resultPathName)
    {
        NXOpen::CAE::FTK::DataManager *pDataMgr = NXOpen::Session::GetSession()->DataManager();
        int  rtc = 0;

        if (boost::filesystem::exists(resultPathName))
        {
            try
            {
                pDataMgr->LoadFile(resultPathName.c_str());
            }
            catch (NXOpen::NXException &ex)
            {
                rtc = ex.ErrorCode();
            }
        }

        return rtc;
    }

}